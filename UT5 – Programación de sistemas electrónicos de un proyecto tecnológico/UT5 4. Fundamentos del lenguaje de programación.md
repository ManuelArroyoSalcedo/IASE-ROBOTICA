# UT5 – Programación de sistemas/circuitos electrónicos de un proyecto tecnológico

---

## Índice de contenidos

1. Conceptos básicos de microcontroladores
2. Uso del entorno de programación de sistemas electrónicos
3. Estructura de un programa para sistemas electrónicos
4. Fundamentos del lenguaje de programación
5. Programación de la comunicación con la placa
6. Análisis del funcionamiento de programas de sistemas electrónicos


---

## 4. Fundamentos del lenguaje de programación

La programación de sistemas electrónicos se basa en el uso de un **lenguaje de programación** que permite describir, mediante instrucciones, el comportamiento que debe seguir el microcontrolador.

Antes de interactuar con sensores, actuadores o pines, es necesario conocer los **elementos básicos del lenguaje**, comunes a muchos entornos de programación.

Arduino utiliza un lenguaje de programación **basado en C/C++**, adaptado y simplificado para facilitar el control de sistemas electrónicos.

A continuación se describen los **principales elementos del lenguaje de programación** utilizados en sistemas electrónicos.

Este apartado presenta los elementos básicos del lenguaje. Algunos de ellos se desarrollan en subapartados posteriores con mayor profundidad.

---

### Índice del apartado

1. [Instrucciones y sentencias](#41-instrucciones-y-sentencias)  
2. [Tipos de datos](#42-tipos-de-datos)  
3. [Variables](#43-variables)  
4. [Constantes](#44-constantes)  
5. [Operadores](#45-operadores)  
6. [Estructuras de control del flujo](#46-estructuras-de-control-del-flujo)  
7. [Estructuras de datos](#47-estructuras-de-datos)  
8. [Subprogramas o funciones](#48-subprogramas-o-funciones)  
9. [Uso de bibliotecas](#49-uso-de-bibliotecas)

---

### 4.1. Instrucciones y sentencias

Un programa está formado por un conjunto de **instrucciones** o **sentencias** que se ejecutan de forma secuencial.

Cada instrucción indica al sistema qué operación debe realizar, como:
- Asignar un valor.
- Evaluar una condición.
- Repetir una acción.
- Llamar a un subprograma.

El orden de las instrucciones influye directamente en el comportamiento del programa.

### 4.2. Tipos de datos

Los lenguajes de programación para sistemas electrónicos trabajan con distintos **tipos de datos**, entre los más habituales en sistemas electrónicos:

- Datos numéricos enteros.
- Datos numéricos con decimales.
- Valores lógicos (verdadero / falso).
- Caracteres y cadenas de texto.

El tipo de dato determina cómo se almacena la información y qué operaciones pueden realizarse sobre ella.

#### 4.2.1. Tipos de datos simples

- **int**: números enteros (por ejemplo: -3, 0, 25)
- **float**: números con decimales (por ejemplo: 3.14, 21.5)
- **bool**: valores lógicos (true / false)
- **char**: un solo carácter (por ejemplo: 'A', '7')

#### 4.2.2. Tipo de dato compuesto

Los tipos compuestos permiten agrupar o manejar información más compleja.

El tipo String es un tipo compuesto proporcionado por el entorno Arduino para facilitar el manejo de texto.

- **String**: texto (por ejemplo: "Hola")

**Ejemplos** (declaración de variables que veremos en el apartado siguiente):

```cpp
int edad = 18;
float voltaje = 4.75;
bool pulsado = true;
char letra = 'M';
String mensaje = "Sistema listo";
```

### 4.3. Variables

Una **variable** es un espacio de memoria identificado por un nombre, cuyo contenido puede cambiar durante la ejecución del programa.

Las variables se utilizan para:
- Almacenar datos.
- Guardar resultados de operaciones.
- Controlar el flujo del programa.

Cada variable tiene asociado un **tipo de dato**, que determina qué valores puede almacenar.

#### 4.3.1. Declaración de variables

En Arduino, una variable se declara indicando:

1. El **tipo de dato**
2. El **nombre** de la variable
3. (Opcional) Un **valor inicial**

Forma general:

```cpp
tipo nombre;
tipo nombre = valor_inicial;
```

Ejemplos:

```cpp
int contador;
int contador = 0;

float temperatura = 21.5;

bool encendido = false;
```

Inicializar una variable significa asignarle un valor al crearla, lo cual ayuda a evitar errores.

#### 4.3.2. Tipos de variables según dónde se declaran (alcance)

Además del tipo de dato, es importante dónde se declara la variable, porque eso determina su **alcance** (dónde puede usarse).

**a) Variables globales**

Se declaran fuera de las funciones  `setup()` y `loop()`.
 Pueden utilizarse desde cualquier parte del programa.

```cpp
int contador = 0;

void setup() {
}

void loop() {
  contador = contador + 1;
}
```

**b) Variables locales**

Se declaran dentro de una función (por ejemplo, dentro de `loop()`).
 Solo existen y se pueden usar dentro de ese bloque.

```cpp
void loop() {
  int lectura = 0;   // variable local
  lectura = lectura + 1;
}
```

Las variables locales se crean al entrar en el bloque y se pierden al salir.

#### 4.3.3. Reglas básicas para nombrar variables

Para evitar errores, los nombres de variables deben cumplir:

- No pueden contener espacios.
- No pueden empezar por un número.
- Distinguen mayúsculas de minúsculas (`valor` y `Valor` no son lo mismo).
- Deben ser nombres claros y relacionados con su uso.

Ejemplos recomendados:

- `contador`
- `temperatura`
- `estadoPulsador`
- `valorSensor`

### 4.4. Constantes

Una **constante** es un valor que no cambia durante la ejecución del programa.

Se utilizan para:
- Definir valores fijos.
- Mejorar la claridad del código.
- Evitar errores al modificar valores repetidos.

El uso de constantes facilita el mantenimiento y la comprensión de los programas.
#### 4.4.1. Declaración de constantes con `const`

La forma recomendada de declarar constantes en Arduino es utilizando la palabra clave `const`.

Forma general:

```cpp
const tipo nombre = valor;
```

Ejemplos:

```cpp
const int LED_PIN = 13;
const float VOLTAJE_MAX = 5.0;
const bool SISTEMA_ACTIVO = true;
```

Una constante declarada con `const`:

- Tiene un tipo de dato.
- Ocupa memoria.
- No puede modificarse una vez declarada.

Si se intenta cambiar su valor, el compilador generará un error.


#### 4.4.2. Declaración de constantes con `#define`

Otra forma de definir constantes es mediante la directiva `#define`.

Forma general:

```cpp
#define NOMBRE valor
```

Ejemplos:

```cpp
#define LED_PIN 13
#define TIEMPO_ESPERA 1000
```

Estas constantes:

- No tienen tipo de dato.
- No ocupan memoria como una variable.
- Son sustituciones de texto realizadas antes de compilar.


#### 4.4.3. Diferencias entre `const` y `#define`

| `const`                     | `#define`               |
| --------------------------- | ----------------------- |
| Tiene tipo de dato          | No tiene tipo           |
| Se comprueba en compilación | No se comprueba el tipo |
| Es más seguro               | Menos seguro            |
| Recomendado                 | Uso limitado            |

En general, se recomienda utilizar **`const`** siempre que sea posible y reservar `#define` para casos muy concretos.


#### 4.4.4. Buenas prácticas al usar constantes

Para mejorar la claridad del código:

- Usar nombres en mayúsculas para las constantes.
- Utilizar constantes en lugar de valores “mágicos”.
- Declarar las constantes al principio del programa.

Ejemplo:

```cpp

const int PIN_PULSADOR = 2;
const int PIN_LED = 13;

void setup() {
  pinMode(PIN_PULSADOR, INPUT);
  pinMode(PIN_LED, OUTPUT);
}
```

De este modo, si cambia el hardware, solo es necesario modificar el valor de la constante.

#### 4.4.5. Constantes predefinidas del entorno

Además de las constantes definidas por el programador, el entorno de Arduino incluye **constantes predefinidas** que representan valores habituales del sistema electrónico.

Algunas de las más utilizadas son:

- `HIGH`: representa el nivel lógico alto (valor 1).
- `LOW`: representa el nivel lógico bajo (valor 0).
- `INPUT`: indica que un pin se configura como entrada.
- `OUTPUT`: indica que un pin se configura como salida.

Estas constantes permiten escribir programas más legibles y evitan el uso directo de valores numéricos.

La **explicación detallada y el uso práctico** de estas constantes se realizará en el apartado dedicado a la **programación de la comunicación con la placa**, donde se aplican directamente sobre los pines del microcontrolador.

### 4.5. Operadores

Los **operadores** permiten realizar operaciones sobre los datos.

Entre los más comunes se encuentran:
- Operadores aritméticos (suma, resta, multiplicación, división).
- Operadores de comparación.
- Operadores lógicos.

Los operadores se utilizan en expresiones que producen un resultado.

#### 4.5.1. Operadores de asignación

Permiten asignar un valor a una variable.

- `=` : asignación simple

Ejemplo:

```cpp
int contador = 0;
contador = 5;
```

También existen operadores de asignación combinada:

- `+=` suma y asigna
- `-=` resta y asigna
- `*=` multiplica y asigna
- `/=` divide y asigna

Ejemplo:

```cpp
contador += 1;   // equivalente a contador = contador + 1
```
#### 4.5.2. Operadores aritméticos

Permiten realizar cálculos matemáticos.

| Operador | Descripción          |
| -------- | -------------------- |
| `+`      | Suma                 |
| `-`      | Resta                |
| `*`      | Multiplicación       |
| `/`      | División             |
| `%`      | Resto de la división |

Ejemplo:

```cpp
int a = 10;
int b = 3;
int resultado = a + b;
int resto = a % b;
```

#### 4.5.3. Operadores de comparación

Permiten comparar dos valores y devuelven un valor lógico (`true` o `false`).

| Operador | Descripción   |
| -------- | ------------- |
| `==`     | Igual que     |
| `!=`     | Distinto de   |
| `>`      | Mayor que     |
| `<`      | Menor que     |
| `>=`     | Mayor o igual |
| `<=`     | Menor o igual |

Ejemplo:

```cpp
int temperatura = 30;

bool alta = temperatura > 25;
```


#### 4.5.4. Operadores lógicos

Permiten combinar condiciones lógicas.

| Operador | Descripción    |
| -------- | -------------- |
| `&&`     | AND (y lógico) |
| `||`     | OR (o lógico)  |
| `!`      | NOT (negación) |

Ejemplo:

```cpp
bool pulsador = true;
bool sistemaActivo = true;

if (pulsador && sistemaActivo) {
  // acción
}
```

#### 4.5.5. Precedencia de operadores (idea básica)

Cuando una expresión contiene varios operadores, estos se evalúan siguiendo un orden de prioridad.

Ejemplo:

```cpp
int resultado = 2 + 3 * 4;
```

Primero se realiza la multiplicación y después la suma.

Para evitar dudas, se recomienda utilizar **paréntesis**:

```cpp
int resultado = (2 + 3) * 4;
```

#### 4.5.6. Buenas prácticas al usar operadores

- Evitar expresiones demasiado largas.
- Utilizar paréntesis para mejorar la claridad.
- Separar operaciones complejas en varias líneas.
- Usar nombres de variables claros.

Los operadores permiten construir expresiones que se utilizarán posteriormente en **condiciones**, **bucles** y **toma de decisiones**.

### 4.6. Estructuras de control del flujo

Las **estructuras de control del flujo** permiten **alterar el orden secuencial** en el que se ejecutan las instrucciones de un programa.

Por defecto, un programa se ejecuta **línea a línea**, de arriba abajo. Sin embargo, en programación de sistemas electrónicos (como los basados en microcontroladores), es necesario **tomar decisiones**, **repetir acciones** y **controlar el comportamiento del sistema** en función de determinadas condiciones.

Las estructuras de control se utilizan para:

- **Tomar decisiones**, ejecutando unas instrucciones u otras según una condición.
- **Repetir bloques de código**, mientras se cumpla una condición o un número determinado de veces.
- **Controlar el funcionamiento de sensores y actuadores**, adaptando el comportamiento del sistema a su estado.

En el contexto de la **programación de sistemas electrónicos**, las estructuras de control permiten, por ejemplo:

- Encender o apagar un LED según el valor leído por un sensor.
- Activar un motor solo cuando se cumpla una determinada condición.
- Ejecutar una acción de forma repetitiva mientras el sistema esté en funcionamiento.
- Responder a eventos externos de forma controlada.

Las principales **estructuras de control del flujo** se clasifican en:

- **Estructuras condicionales**, que permiten decidir qué instrucciones se ejecutan.
- **Estructuras repetitivas o bucles**, que permiten ejecutar instrucciones de forma repetida.

Estas estructuras se desarrollarán con más detalle en los apartados siguientes, junto con ejemplos prácticos aplicados a la programación de sistemas electrónicos.

#### 4.6.1. Estructuras condicionales

Las **estructuras condicionales** permiten que un programa **tome decisiones**, ejecutando unas instrucciones u otras en función de si se cumple una condición.

Una condición es una **expresión lógica** que puede evaluarse como:

- Verdadera (`true`)
- Falsa (`false`)

En la programación de **sistemas electrónicos**, las estructuras condicionales se utilizan, por ejemplo, para:

- Encender o apagar un LED según el valor de un sensor.
- Activar un actuador solo cuando se cumple una condición.
- Cambiar el comportamiento del sistema en función del estado de una entrada.

##### 1. Estructura condicional simple: `if`

La estructura `if` permite ejecutar un bloque de código **solo si la condición es verdadera**.

###### Sintaxis general

```cpp
if (condición) {
    instrucciones;
}
```

- Si la condición es verdadera, se ejecutan las instrucciones.
- Si la condición es falsa, el bloque se ignora.

###### Ejemplo

```cpp
if (temperatura > 30) {
    digitalWrite(LED_BUILTIN, HIGH);
}
```

##### 2. Estructura condicional doble: `if – else`

La estructura `if – else` permite elegir entre **dos caminos posibles**.

###### Sintaxis general

```cpp
if (condición) {
    instrucciones_si_verdadero;
} else {
    instrucciones_si_falso;
}
```

###### Ejemplo

```cpp
if (luz < 500) {
    digitalWrite(LED_BUILTIN, HIGH);
} else {
    digitalWrite(LED_BUILTIN, LOW);
}
```

##### 3. Estructura condicional múltiple: `if – else if – else`

Se utiliza cuando es necesario evaluar **varias condiciones**.

###### Sintaxis general

```cpp
if (condición1) {
    instrucciones1;
} else if (condición2) {
    instrucciones2;
} else {
    instrucciones_por_defecto;
}
```

Las condiciones se evalúan **en orden** y solo se ejecuta el primer bloque cuya condición sea verdadera.

###### Ejemplo

```cpp
if (temperatura < 15) {    
    Serial.println("Hace frío"); 
} else if (temperatura < 30) {    
    Serial.println("Temperatura normal"); 
} else {    
    Serial.println("Hace calor"); 
}
```

##### 4. Buenas prácticas en el uso de condicionales

- Las condiciones deben ser **claras y fáciles de entender**.
- Evitar condicionales excesivamente largos o difíciles de leer.
- Usar una **indentación correcta** para mejorar la legibilidad.
- Revisar el orden de evaluación en estructuras con múltiples condiciones.

##### 5. Importancia de los condicionales en sistemas electrónicos

Las estructuras condicionales permiten que un sistema electrónico:

- Reaccione a señales de sensores.
- Tome decisiones automáticamente.
- Controle actuadores de forma lógica.
- Adapte su comportamiento al entorno.

Sin estructuras condicionales, un sistema electrónico tendría un comportamiento **fijo y no adaptable**.

#### 4.6.2. Estructuras repetitivas (bucles)

Las **estructuras repetitivas**, también llamadas **bucles**, permiten ejecutar un bloque de instrucciones **varias veces**, de forma controlada.

En programación de sistemas electrónicos, los bucles se utilizan para:

- Repetir acciones mientras el sistema está en funcionamiento.
- Comprobar continuamente el estado de sensores o entradas.
- Ejecutar tareas de forma periódica.
- Automatizar procesos sin necesidad de repetir código.

##### 1. Concepto de bucle

Un bucle repite un conjunto de instrucciones mientras se cumpla una condición o durante un número determinado de iteraciones.

Todo bucle debe tener:

- Una **condición de repetición** o un **contador**.
- Un **bloque de instrucciones** que se repite.
- Un **criterio de finalización** para evitar repeticiones infinitas no deseadas.

##### 2. Bucle `while`

El bucle `while` ejecuta un bloque de código **mientras la condición sea verdadera**.

La condición se evalúa **antes** de ejecutar el bloque.

###### Sintaxis general

```cpp
while (condición) {
    instrucciones;
}
```

- Si la condición es falsa desde el inicio, el bloque no se ejecuta ninguna vez.
- Es habitual usar `while` cuando no se conoce de antemano cuántas veces se repetirá el bucle.

###### Ejemplo

```cpp
while (boton == HIGH) {
    digitalWrite(LED_BUILTIN, HIGH);
}
```

##### 3. Bucle `do – while`

El bucle `do – while` es similar al `while`, pero la condición se evalúa **al final** del bucle.

Esto garantiza que el bloque de instrucciones se ejecute **al menos una vez**.

###### Sintaxis general

```cpp
do {
    instrucciones;
} while (condición);
```

###### Ejemplo

```cpp
do {
    Serial.println("Ejecutando...");
} while (sensor == HIGH);
```

##### 4. Bucle `for`

El bucle `for` se utiliza cuando se conoce **de antemano** el número de repeticiones.

Está compuesto por tres partes:

- Inicialización del contador.
- Condición de repetición.
- Actualización del contador.

###### Sintaxis general

```cpp
for (inicialización; condición; actualización) {
    instrucciones;
}
```

###### Ejemplo

```cpp

for (int i = 0; i < 5; i++) {
    Serial.println(i);
}
```

Este bucle se ejecuta cinco veces, con valores de `i` de 0 a 4.

##### 5. Uso de bucles en sistemas electrónicos

En sistemas electrónicos programados con microcontroladores, los bucles permiten:

- Leer sensores de forma continua.
- Controlar actuadores de manera repetitiva.
- Ejecutar tareas periódicas sin intervención del usuario.
- Mantener el sistema activo mientras esté alimentado.

En Arduino, el propio programa principal se ejecuta de forma repetitiva, lo que hace que el uso de bucles sea especialmente importante.

##### 6. Buenas prácticas en el uso de bucles

- Asegurar siempre una **condición de salida** clara.
- Evitar bucles infinitos no controlados.
- Usar el tipo de bucle más adecuado según el problema.
- Mantener el código del bucle claro y legible.

##### 7. Importancia de los bucles

Las estructuras repetitivas son fundamentales porque permiten:

- Automatizar tareas.
- Reducir la repetición de código.
- Controlar procesos continuos.
- Gestionar el funcionamiento cíclico de los sistemas electrónicos.

Sin bucles, un programa no podría realizar tareas repetitivas ni adaptarse a un entorno dinámico.

### 4.7. Estructuras de datos

Las **estructuras de datos** permiten **almacenar y organizar varios datos relacionados** bajo un mismo nombre.

Mientras que una variable almacena **un solo valor**, una estructura de datos permite trabajar con **conjuntos de valores**, lo que resulta especialmente útil en programación de sistemas electrónicos para:

- Guardar varias lecturas de sensores.
- Manejar estados o configuraciones.
- Repetir acciones sobre un conjunto de datos.
- Simplificar el código y evitar variables repetidas.

En este módulo se trabajarán **estructuras de datos sencillas**, adecuadas al nivel del curso y al entorno Arduino.

#### 4.7.1. Arrays (vectores)

Un **array** es una estructura de datos que permite almacenar **varios valores del mismo tipo** bajo un mismo nombre.

Cada valor del array se identifica mediante un **índice**, que comienza siempre en **0**.

##### Características de los arrays

- Todos los elementos son del **mismo tipo de dato**.
- Tienen un **tamaño fijo**, que se define al crearlo.
- Se accede a cada elemento mediante su índice.

##### Declaración de un array

Forma general:

```cpp
tipo nombre[tamaño];
```

Ejemplo:

```cpp
int valores[5];
```

Este array puede almacenar cinco valores enteros, con índices del 0 al 4.

También se puede inicializar al declararlo:

```cpp
int valores[5] = {10, 20, 30, 40, 50};
```


##### Acceso a los elementos de un array

Para acceder a un elemento concreto se utiliza su índice:

```cpp
valores[0] = 15;      // primer elemento
valores[2] = 35;      // tercer elemento
```

Ejemplo de lectura:

```cpp
int x = valores[1];
```

##### Uso de arrays con bucles

Los arrays se utilizan habitualmente junto con **bucles**, lo que permite recorrer todos sus elementos de forma sencilla.

Ejemplo:

```cpp
for (int i = 0; i < 5; i++) {
    Serial.println(valores[i]);
}
```

Este bucle recorre todo el array y muestra cada valor por el puerto serie.

##### Aplicaciones de los arrays en sistemas electrónicos

En programación de sistemas electrónicos, los arrays se utilizan, por ejemplo, para:

- Almacenar varias lecturas de un sensor.
- Controlar múltiples LEDs o actuadores.
- Guardar estados o configuraciones del sistema.
- Procesar datos de forma repetitiva.

#### 4.7.2. Listas y colecciones (idea básica)

En lenguajes de programación de propósito general existen estructuras de datos
dinámicas, como listas o colecciones, cuyo tamaño puede cambiar durante la
ejecución del programa.

El lenguaje utilizado en Arduino permite este tipo de estructuras, pero su uso
no es habitual ni recomendable en programación básica de sistemas electrónicos,
debido a las limitaciones de memoria y a la complejidad que introducen.

Por este motivo, en este módulo se trabajará principalmente con arrays como
estructura de datos fundamental.

El concepto de lista se introduce únicamente como idea general, para comprender
que existen otras formas de organizar datos en programación, que se verán en
lenguajes o entornos más avanzados.

#### 4.7.3. Buenas prácticas en el uso de estructuras de datos

- Utilizar arrays solo cuando sea necesario almacenar varios valores relacionados.
- Elegir un tamaño adecuado al crear el array.
- Usar nombres claros y representativos.
- Recorrer los arrays mediante bucles para evitar código repetitivo.
- Evitar acceder a posiciones fuera del tamaño del array.

#### 4.7.4. Importancia de las estructuras de datos

Las estructuras de datos permiten:

- Organizar mejor la información del programa.
- Simplificar el código.
- Mejorar la claridad y el mantenimiento.
- Facilitar el uso de bucles y estructuras de control.

En sistemas electrónicos, el uso adecuado de estructuras de datos contribuye a programas más eficientes y fáciles de entender.

### 4.8. Subprogramas o funciones

Un **subprograma** o **función** es un bloque de código que realiza una tarea concreta y que puede ejecutarse desde distintos puntos del programa.

El uso de funciones permite dividir un programa en partes más pequeñas, facilitando su comprensión, reutilización y mantenimiento.

Las funciones son un elemento fundamental en la programación de sistemas electrónicos, especialmente cuando el programa comienza a crecer en tamaño y complejidad.


#### 4.8.1. Concepto de función

Una función es un conjunto de instrucciones que:

- Tiene un **nombre** identificativo.
- Puede recibir **datos de entrada** mediante parámetros.
- Puede devolver un **resultado**.
- Realiza una tarea concreta.

Gracias a las funciones, un programa puede organizarse en bloques lógicos independientes.


#### 4.8.2. Declaración y definición de funciones

Para definir una función en Arduino es necesario indicar:

1. El **tipo de dato** que devuelve.
2. El **nombre** de la función.
3. Los **parámetros** que recibe, si los hay.
4. El **bloque de instrucciones** que ejecuta.

Forma general:

```cpp
tipo_retorno nombreFuncion(parametros) {
    instrucciones;
}
```

Ejemplo de función sin parámetros y sin valor de retorno:

```cpp
void encenderLED() {
    digitalWrite(LED_BUILTIN, HIGH);
}
```

#### 4.8.3. Llamada a una función

Para ejecutar una función se utiliza su nombre seguido de paréntesis.

Ejemplo:

```cpp
encenderLED();
```

Cuando se llama a una función, el programa ejecuta sus instrucciones y, al finalizar, continúa con la siguiente instrucción del programa principal.

#### 4.8.4. Funciones con parámetros

Las funciones pueden recibir **parámetros**, que son valores que se pasan a la función en el momento de la llamada.

Ejemplo:

```cpp
void encenderPin(int pin) {
    digitalWrite(pin, HIGH);
}
```

Llamada a la función:

```cpp
encenderPin(13);
```

Los parámetros permiten reutilizar una misma función con distintos valores.


#### 4.8.5. Funciones con valor de retorno

Una función puede devolver un valor al programa que la llama mediante la instrucción `return`.

Ejemplo:

```cpp
int sumar(int a, int b) {
    return a + b;
}
```

Uso de la función:

```cpp
int resultado = sumar(3, 5);
```

El valor devuelto puede almacenarse en una variable o utilizarse en una expresión.

#### 4.8.6. Funciones sin valor de retorno (`void`)

Cuando una función no necesita devolver ningún valor, se utiliza el tipo `void`.

Este tipo de funciones se emplea habitualmente para realizar acciones, como activar dispositivos o mostrar información.

Ejemplo:

```cpp
void mostrarMensaje() {
    Serial.println("Sistema en funcionamiento");
}
```

#### 4.8.7. Uso de funciones en sistemas electrónicos

En la programación de sistemas electrónicos, las funciones se utilizan para:

- Agrupar acciones relacionadas.
- Controlar sensores y actuadores.
- Evitar la repetición de código.
- Simplificar el contenido del programa principal (`loop()`).

Ejemplo de uso en el programa principal:

```cpp
void loop() {
    leerSensor();
    controlarLED();
}
```

#### 4.8.8. Buenas prácticas en el uso de funciones

Para un uso correcto de las funciones se recomienda:

- Utilizar nombres claros y descriptivos.
- Diseñar funciones que realicen una única tarea.
- Evitar funciones demasiado largas.
- Reutilizar funciones siempre que sea posible.
- Mantener una estructura clara y bien indentada.

#### 4.8.9. Importancia de las funciones

El uso de funciones permite:

- Mejorar la organización del programa.
- Facilitar la lectura y comprensión del código.
- Simplificar el mantenimiento y las modificaciones.
- Desarrollar programas más claros y estructurados.

En sistemas electrónicos, las funciones contribuyen a crear programas más robustos y fáciles de entender.

### 4.9. Uso de bibliotecas

Una **biblioteca** es un conjunto de funciones, definiciones y recursos previamente creados que amplían las capacidades del lenguaje de programación.

Las bibliotecas permiten al programador utilizar funcionalidades ya desarrolladas sin necesidad de programarlas desde cero.

El uso de bibliotecas es habitual en programación de sistemas electrónicos y forma parte del desarrollo normal de programas con microcontroladores.

#### 4.9.1. Finalidad del uso de bibliotecas

Las bibliotecas se utilizan para:

- Simplificar tareas complejas.
- Reutilizar código ya probado y validado.
- Reducir errores de programación.
- Acelerar el desarrollo de aplicaciones.
- Facilitar el trabajo con sensores, actuadores y dispositivos externos.

Gracias a las bibliotecas, el programador puede centrarse en la lógica del programa en lugar de en los detalles internos de funcionamiento del hardware.

#### 4.9.2. Bibliotecas en el entorno Arduino

El entorno Arduino incluye numerosas bibliotecas que permiten trabajar de forma sencilla con:

- Comunicación serie.
- Sensores.
- Pantallas.
- Módulos de comunicación.
- Actuadores.

Algunas bibliotecas están incluidas por defecto en el entorno y otras pueden añadirse según las necesidades del proyecto.

#### 4.9.3. Inclusión de una biblioteca en un programa

Para utilizar una biblioteca en un programa es necesario **incluirla** al inicio del código mediante la directiva `#include`.

Ejemplo:

```cpp
#include <Arduino.h>
```

Una vez incluida la biblioteca, se pueden utilizar las funciones y recursos que proporciona.

La inclusión de bibliotecas suele realizarse al comienzo del programa, antes de las declaraciones de variables y funciones.

#### 4.9.4. Uso de funciones de una biblioteca

Las bibliotecas proporcionan funciones que pueden utilizarse igual que las funciones definidas por el programador.

Ejemplo:

```cpp
Serial.begin(9600);
Serial.println("Hola");
```

En este caso, las funciones utilizadas pertenecen a la biblioteca de comunicación serie incluida en el entorno Arduino.

#### 4.9.5. Buenas prácticas en el uso de bibliotecas

Para un uso correcto de las bibliotecas se recomienda:

- Utilizar solo las bibliotecas necesarias para el proyecto.
- Leer la documentación básica de la biblioteca antes de usarla.
- Evitar incluir bibliotecas que no se utilicen.
- Mantener el código claro y ordenado.

#### 4.9.6. Importancia del uso de bibliotecas

El uso de bibliotecas permite:

- Ampliar las capacidades del lenguaje de programación.
- Trabajar con hardware complejo de forma sencilla.
- Crear programas más robustos y fiables.
- Desarrollar proyectos de mayor complejidad con menos esfuerzo.

En programación de sistemas electrónicos, las bibliotecas son una herramienta esencial para aprovechar todo el potencial del microcontrolador.
